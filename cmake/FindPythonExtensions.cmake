# from https://github.com/scikit-build/scikit-build/blob/master/skbuild/resources/cmake/FindPythonExtensions.cmake
#.rst:
#
# This module defines CMake functions to build Python extension modules and
# stand-alone executables.
#
# The following variables are defined:
# ::
#
#   PYTHON_PREFIX                     - absolute path to the current Python
#                                       distribution's prefix
#   PYTHON_SITE_PACKAGES_DIR          - absolute path to the current Python
#                                       distribution's site-packages directory
#   PYTHON_RELATIVE_SITE_PACKAGES_DIR - path to the current Python
#                                       distribution's site-packages directory
#                                       relative to its prefix
#   PYTHON_SEPARATOR                  - separator string for file path
#                                       components.  Equivalent to ``os.sep`` in
#                                       Python.
#   PYTHON_PATH_SEPARATOR             - separator string for PATH-style
#                                       environment variables.  Equivalent to
#                                       ``os.pathsep`` in Python.
#   PYTHON_EXTENSION_MODULE_SUFFIX    - suffix of the compiled module. For example, on
#                                       Linux, based on environment, it could be ``.cpython-35m-x86_64-linux-gnu.so``.
#
#
#
# The following functions are defined:
#
# .. cmake:command:: python_extension_module
#
# For libraries meant to be used as Python extension modules, either dynamically
# loaded or directly linked.  Amend the configuration of the library target
# (created using ``add_library``) with additional options needed to build and
# use the referenced library as a Python extension module.
#
#   python_extension_module(<Target>
#                           [LINKED_MODULES_VAR <LinkedModVar>]
#                           [FORWARD_DECL_MODULES_VAR <ForwardDeclModVar>]
#                           [MODULE_SUFFIX <ModuleSuffix>])
#
# Only extension modules that are configured to be built as MODULE libraries can
# be runtime-loaded through the standard Python import mechanism.  All other
# modules can only be included in standalone applications that are written to
# expect their presence.  In addition to being linked against the libraries for
# these modules, such applications must forward declare their entry points and
# initialize them prior to use.  To generate these forward declarations and
# initializations, see ``python_modules_header``.
#
# If ``<Target>`` does not refer to a target, then it is assumed to refer to an
# extension module that is not linked at all, but compiled along with other
# source files directly into an executable.  Adding these modules does not cause
# any library configuration modifications, and they are not added to the list of
# linked modules.  They still must be forward declared and initialized, however,
# and so are added to the forward declared modules list.
#
# If the associated target is of type ``MODULE_LIBRARY``, the LINK_FLAGS target
# property is used to set symbol visibility and export only the module init function.
# This applies to GNU and MSVC compilers.
#
# Options:
#
# ``LINKED_MODULES_VAR <LinkedModVar>``
#   Name of the variable referencing a list of extension modules whose libraries
#   must be linked into the executables of any stand-alone applications that use
#   them.  By default, the global property ``PY_LINKED_MODULES_LIST`` is used.
#
# ``FORWARD_DECL_MODULES_VAR <ForwardDeclModVar>``
#   Name of the variable referencing a list of extension modules whose entry
#   points must be forward declared and called by any stand-alone applications
#   that use them.  By default, the global property
#   ``PY_FORWARD_DECL_MODULES_LIST`` is used.
#
# ``MODULE_SUFFIX <ModuleSuffix>``
#   Suffix appended to the python extension module file.
#   The default suffix is retrieved using ``sysconfig.get_config_var("SO")"``,
#   if not available, the default is then ``.so`` on unix and ``.pyd`` on
#   windows.
#   Setting the variable ``PYTHON_EXTENSION_MODULE_SUFFIX`` in the caller
#   scope defines the value used for all extensions not having a suffix
#   explicitly specified using ``MODULE_SUFFIX`` parameter.
#
#
# .. cmake:command:: python_standalone_executable
#
#   python_standalone_executable(<Target>)
#
# For standalone executables that initialize their own Python runtime
# (such as when building source files that include one generated by Cython with
# the --embed option).  Amend the configuration of the executable target
# (created using ``add_executable``) with additional options needed to properly
# build the referenced executable.
#
#
# .. cmake:command:: python_modules_header
#
# Generate a header file that contains the forward declarations and
# initialization routines for the given list of Python extension modules.
# ``<Name>`` is the logical name for the header file (no file extensions).
# ``<HeaderFilename>`` is the actual destination filename for the header file
# (e.g.: decl_modules.h).
#
#   python_modules_header(<Name> [HeaderFilename]
#                         [FORWARD_DECL_MODULES_LIST <ForwardDeclModList>]
#                         [HEADER_OUTPUT_VAR <HeaderOutputVar>]
#                         [INCLUDE_DIR_OUTPUT_VAR <IncludeDirOutputVar>])
#
# If only ``<Name>`` is provided, and it ends in the ".h" extension, then it
# is assumed to be the ``<HeaderFilename>``.  The filename of the header file
# without the extension is used as the logical name.  If only ``<Name>`` is
# provided, and it does not end in the ".h" extension, then the
# ``<HeaderFilename>`` is assumed to ``<Name>.h``.
#
# The exact contents of the generated header file depend on the logical
# ``<Name>``.  It should be set to a value that corresponds to the target
# application, or for the case of multiple applications, some identifier that
# conveyes its purpose.  It is featured in the generated multiple inclusion
# guard as well as the names of the generated initialization routines.
#
# The generated header file includes forward declarations for all listed
# modules, as well as implementations for the following class of routines:
#
# ``int <Name>_<Module>(void)``
#   Initializes the python extension module, ``<Module>``.  Returns an integer
#   handle to the module.
#
# ``void <Name>_LoadAllPythonModules(void)``
#   Initializes all listed python extension modules.
#
# ``void CMakeLoadAllPythonModules(void);``
#   Alias for ``<Name>_LoadAllPythonModules`` whose name does not depend on
#   ``<Name>``.  This function is excluded during preprocessing if the
#   preprocessing macro ``EXCLUDE_LOAD_ALL_FUNCTION`` is defined.
#
# ``void Py_Initialize_Wrapper();``
#   Wrapper arpund ``Py_Initialize()`` that initializes all listed python
#   extension modules.  This function is excluded during preprocessing if the
#   preprocessing macro ``EXCLUDE_PY_INIT_WRAPPER`` is defined.  If this
#   function is generated, then ``Py_Initialize()`` is redefined to a macro
#   that calls this function.
#
# Options:
#
# ``FORWARD_DECL_MODULES_LIST <ForwardDeclModList>``
#   List of extension modules for which to generate forward declarations of
#   their entry points and their initializations.  By default, the global
#   property ``PY_FORWARD_DECL_MODULES_LIST`` is used.
#
# ``HEADER_OUTPUT_VAR <HeaderOutputVar>``
#   Name of the variable to set to the path to the generated header file.  By
#   default, ``<Name>`` is used.
#
# ``INCLUDE_DIR_OUTPUT_VAR <IncludeDirOutputVar>``
#   Name of the variable to set to the path to the directory containing the
#   generated header file.  By default, ``<Name>_INCLUDE_DIRS`` is used.
#
# Defined variables:
#
# ``<HeaderOutputVar>``
#   The path to the generated header file
#
# ``<IncludeDirOutputVar>``
#   Directory containing the generated header file
#
#
# Example usage
# ^^^^^^^^^^^^^
#
# .. code-block:: cmake
#
#    find_package(PythonInterp)
#    find_package(PythonLibs)
#    find_package(PythonExtensions)
#    find_package(Cython)
#    find_package(Boost COMPONENTS python)
#
#    # Simple Cython Module -- no executables
#    add_cython_target(_module.pyx)
#    add_library(_module MODULE ${_module})
#    python_extension_module(_module)
#
#    # Mix of Cython-generated code and C++ code using Boost Python
#    # Stand-alone executable -- no modules
#    include_directories(${Boost_INCLUDE_DIRS})
#    add_cython_target(main.pyx CXX EMBED_MAIN)
#    add_executable(main boost_python_module.cxx ${main})
#    target_link_libraries(main ${Boost_LIBRARIES})
#    python_standalone_executable(main)
#
#    # stand-alone executable with three extension modules:
#    # one statically linked, one dynamically linked, and one loaded at runtime
#    #
#    # Freely mixes Cython-generated code, code using Boost-Python, and
#    # hand-written code using the CPython API.
#
#    # module1 -- statically linked
#    add_cython_target(module1.pyx)
#    add_library(module1 STATIC ${module1})
#    python_extension_module(module1
#                            LINKED_MODULES_VAR linked_module_list
#                            FORWARD_DECL_MODULES_VAR fdecl_module_list)
#
#    # module2 -- dynamically linked
#    include_directories({Boost_INCLUDE_DIRS})
#    add_library(module2 SHARED boost_module2.cxx)
#    target_link_libraries(module2 ${Boost_LIBRARIES})
#    python_extension_module(module2
#                            LINKED_MODULES_VAR linked_module_list
#                            FORWARD_DECL_MODULES_VAR fdecl_module_list)
#
#    # module3 -- loaded at runtime
#    add_cython_target(module3a.pyx)
#    add_library(module3 MODULE ${module3a} module3b.cxx)
#    target_link_libraries(module3 ${Boost_LIBRARIES})
#    python_extension_module(module3
#                            LINKED_MODULES_VAR linked_module_list
#                            FORWARD_DECL_MODULES_VAR fdecl_module_list)
#
#    # application executable -- generated header file + other source files
#    python_modules_header(modules
#                          FORWARD_DECL_MODULES_LIST ${fdecl_module_list})
#    include_directories(${modules_INCLUDE_DIRS})
#
#    add_cython_target(mainA)
#    add_cython_target(mainC)
#    add_executable(main ${mainA} mainB.cxx ${mainC} mainD.c)
#
#    target_link_libraries(main ${linked_module_list} ${Boost_LIBRARIES})
#    python_standalone_executable(main)
#
#=============================================================================
# Copyright 2011 Kitware, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#=============================================================================

find_package(PythonInterp REQUIRED)
find_package(PythonLibs)

#.rst:
#
# Public Functions
# ^^^^^^^^^^^^^^^^
#
# The following functions are defined:
#
# .. cmake:command:: target_link_libraries_with_dynamic_lookup
#
# ::
#
#     target_link_libraries_with_dynamic_lookup(<Target> [<Libraries>])
#
#
# Useful to "weakly" link a loadable module. For example, it should be used
# when compiling a loadable module when the symbols should be resolve from
# the run-time environment where the module is loaded, and not a specific
# system library.
#
# Like proper linking, except that the given ``<Libraries>`` are not necessarily
# linked. Instead, the ``<Target>`` is produced in a manner that allows for
# symbols unresolved within it to be resolved at runtime, presumably by the
# given ``<Libraries>``.  If such a target can be produced, the provided
# ``<Libraries>`` are not actually linked.
#
# It links a library to a target such that the symbols are resolved at
# run-time not link-time.
#
# The linker is checked to see if it supports undefined
# symbols when linking a shared library. If it does then the library
# is not linked when specified with this function.
#
# On platforms that do not support weak-linking, this function works just
# like ``target_link_libraries``.
#
# .. note::
#
#     For OSX it uses ``undefined dynamic_lookup``. This is similar to using
#     ``-shared`` on Linux where undefined symbols are ignored.
#
#     For more details, see `blog <http://blog.tim-smith.us/2015/09/python-extension-modules-os-x/>`_
#     from Tim D. Smith.
#
#
# .. cmake:command:: check_dynamic_lookup
#
# Check if the linker requires a command line flag to allow leaving symbols
# unresolved when producing a target of type ``<TargetType>`` that is
# weakly-linked against a dependency of type ``<LibType>``.
#
# ``<TargetType>``
#   can be one of "STATIC", "SHARED", "MODULE", or "EXE".
#
# ``<LibType>``
#   can be one of "STATIC", "SHARED", or "MODULE".
#
# Long signature:
#
# ::
#
#     check_dynamic_lookup(<TargetType>
#                          <LibType>
#                          <ResultVar>
#                          [<LinkFlagsVar>])
#
#
# Short signature:
#
# ::
#
#     check_dynamic_lookup(<ResultVar>) # <TargetType> set to "MODULE"
#                                       # <LibType> set to "SHARED"
#
#
# The result is cached between invocations and recomputed only when the value
# of CMake's linker flag list changes; ``CMAKE_STATIC_LINKER_FLAGS`` if
# ``<TargetType>`` is "STATIC", and ``CMAKE_SHARED_LINKER_FLAGS`` otherwise.
#
#
# Defined variables:
#
# ``<ResultVar>``
#   Whether the current C toolchain supports weak-linking for target binaries of
#   type ``<TargetType>`` that are weakly-linked against a dependency target of
#   type ``<LibType>``.
#
# ``<LinkFlagsVar>``
#   List of flags to add to the linker command to produce a working target
#   binary of type ``<TargetType>`` that is weakly-linked against a dependency
#   target of type ``<LibType>``.
#
# ``HAS_DYNAMIC_LOOKUP_<TargetType>_<LibType>``
#   Cached, global alias for ``<ResultVar>``
#
# ``DYNAMIC_LOOKUP_FLAGS_<TargetType>_<LibType>``
#   Cached, global alias for ``<LinkFlagsVar>``
#
#
# Private Functions
# ^^^^^^^^^^^^^^^^^
#
# The following private functions are defined:
#
# .. warning:: These functions are not part of the scikit-build API. They
#     exist purely as an implementation detail and may change from version
#     to version without notice, or even be removed.
#
#     We mean it.
#
#
# .. cmake:command:: _get_target_type
#
# ::
#
#     _get_target_type(<ResultVar> <Target>)
#
#
# Shorthand for querying an abbreviated version of the target type
# of the given ``<Target>``.
#
# ``<ResultVar>`` is set to:
#
# - "STATIC" for a STATIC_LIBRARY,
# - "SHARED" for a SHARED_LIBRARY,
# - "MODULE" for a MODULE_LIBRARY,
# - and "EXE" for an EXECUTABLE.
#
# Defined variables:
#
# ``<ResultVar>``
#   The abbreviated version of the ``<Target>``'s type.
#
#
# .. cmake:command:: _test_weak_link_project
#
# ::
#
#     _test_weak_link_project(<TargetType>
#                             <LibType>
#                             <ResultVar>
#                             <LinkFlagsVar>)
#
#
# Attempt to compile and run a test project where a target of type
# ``<TargetType>`` is weakly-linked against a dependency of type ``<LibType>``:
#
# - ``<TargetType>`` can be one of "STATIC", "SHARED", "MODULE", or "EXE".
# - ``<LibType>`` can be one of "STATIC", "SHARED", or "MODULE".
#
# Defined variables:
#
# ``<ResultVar>``
#   Whether the current C toolchain can produce a working target binary of type
#   ``<TargetType>`` that is weakly-linked against a dependency target of type
#   ``<LibType>``.
#
# ``<LinkFlagsVar>``
#   List of flags to add to the linker command to produce a working target
#   binary of type ``<TargetType>`` that is weakly-linked against a dependency
#   target of type ``<LibType>``.
#

function(_get_target_type result_var target)
  set(target_type "SHARED_LIBRARY")
  if(TARGET ${target})
    get_property(target_type TARGET ${target} PROPERTY TYPE)
  endif()

  set(result "STATIC")

  if(target_type STREQUAL "STATIC_LIBRARY")
    set(result "STATIC")
  endif()

  if(target_type STREQUAL "SHARED_LIBRARY")
    set(result "SHARED")
  endif()

  if(target_type STREQUAL "MODULE_LIBRARY")
    set(result "MODULE")
  endif()

  if(target_type STREQUAL "EXECUTABLE")
    set(result "EXE")
  endif()

  set(${result_var} ${result} PARENT_SCOPE)
endfunction()


function(_test_weak_link_project
         target_type
         lib_type
         can_weak_link_var
         project_name)

  set(gnu_ld_ignore      "-Wl,--unresolved-symbols=ignore-all")
  set(osx_dynamic_lookup           "-undefined dynamic_lookup")
  set(no_flag                                               "")

  foreach(link_flag_spec gnu_ld_ignore osx_dynamic_lookup no_flag)
    set(link_flag "${${link_flag_spec}}")

    set(test_project_dir "${PROJECT_BINARY_DIR}/CMakeTmp")
    set(test_project_dir "${test_project_dir}/${project_name}")
    set(test_project_dir "${test_project_dir}/${link_flag_spec}")
    set(test_project_dir "${test_project_dir}/${target_type}")
    set(test_project_dir "${test_project_dir}/${lib_type}")

    set(test_project_src_dir "${test_project_dir}/src")
    set(test_project_bin_dir "${test_project_dir}/build")

    file(MAKE_DIRECTORY ${test_project_src_dir})
    file(MAKE_DIRECTORY ${test_project_bin_dir})

    set(mod_type "STATIC")
    set(link_mod_lib TRUE)
    set(link_exe_lib TRUE)
    set(link_exe_mod FALSE)

    if("${target_type}" STREQUAL "EXE")
      set(link_exe_lib FALSE)
      set(link_exe_mod TRUE)
    else()
      set(mod_type "${target_type}")
    endif()

    if("${mod_type}" STREQUAL "MODULE")
      set(link_mod_lib FALSE)
    endif()


    file(WRITE "${test_project_src_dir}/CMakeLists.txt" "
      cmake_minimum_required(VERSION ${CMAKE_VERSION})
      project(${project_name} C)

      include_directories(${test_project_src_dir})

      add_library(number ${lib_type} number.c)
      add_library(counter ${mod_type} counter.c)
    ")

    if("${mod_type}" STREQUAL "MODULE")
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        set_target_properties(counter PROPERTIES PREFIX \"\")
      ")
    endif()

    if(link_mod_lib)
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        target_link_libraries(counter number)
      ")
    elseif(NOT link_flag STREQUAL "")
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        set_target_properties(counter PROPERTIES LINK_FLAGS \"${link_flag}\")
      ")
    endif()

    file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
      add_executable(main main.c)
    ")

    if(link_exe_lib)
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        target_link_libraries(main number)
      ")
    elseif(NOT link_flag STREQUAL "")
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        target_link_libraries(main \"${link_flag}\")
      ")
    endif()

    if(link_exe_mod)
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        target_link_libraries(main counter)
      ")
    else()
      file(APPEND "${test_project_src_dir}/CMakeLists.txt" "
        target_link_libraries(main \"${CMAKE_DL_LIBS}\")
      ")
    endif()

    file(WRITE "${test_project_src_dir}/number.c" "
      #include <number.h>

      static int _number;
      void set_number(int number) { _number = number; }
      int get_number() { return _number; }
    ")

    file(WRITE "${test_project_src_dir}/number.h" "
      #ifndef _NUMBER_H
      #define _NUMBER_H
      extern void set_number(int);
      extern int get_number(void);
      #endif
    ")

    file(WRITE "${test_project_src_dir}/counter.c" "
      #include <number.h>
      int count() {
        int result = get_number();
        set_number(result + 1);
        return result;
      }
    ")

    file(WRITE "${test_project_src_dir}/counter.h" "
      #ifndef _COUNTER_H
      #define _COUNTER_H
      extern int count(void);
      #endif
    ")

    file(WRITE "${test_project_src_dir}/main.c" "
      #include <stdlib.h>
      #include <stdio.h>
      #include <number.h>
    ")

    if(NOT link_exe_mod)
      file(APPEND "${test_project_src_dir}/main.c" "
        #include <dlfcn.h>
      ")
    endif()

    file(APPEND "${test_project_src_dir}/main.c" "
      int my_count() {
        int result = get_number();
        set_number(result + 1);
        return result;
      }

      int main(int argc, char **argv) {
        int result;
    ")

    if(NOT link_exe_mod)
      file(APPEND "${test_project_src_dir}/main.c" "
        void *counter_module;
        int (*count)(void);

        counter_module = dlopen(\"./counter.so\", RTLD_LAZY | RTLD_GLOBAL);
        if(!counter_module) goto error;

        count = dlsym(counter_module, \"count\");
        if(!count) goto error;
      ")
    endif()

    file(APPEND "${test_project_src_dir}/main.c" "
        result = count()    != 0 ? EXIT_FAILURE :
                 my_count() != 1 ? EXIT_FAILURE :
                 my_count() != 2 ? EXIT_FAILURE :
                 count()    != 3 ? EXIT_FAILURE :
                 count()    != 4 ? EXIT_FAILURE :
                 count()    != 5 ? EXIT_FAILURE :
                 my_count() != 6 ? EXIT_FAILURE : EXIT_SUCCESS;
    ")

    if(NOT link_exe_mod)
      file(APPEND "${test_project_src_dir}/main.c" "
        goto done;
        error:
          fprintf(stderr, \"Error occured:\\n    %s\\n\", dlerror());
          result = 1;

        done:
          if(counter_module) dlclose(counter_module);
      ")
    endif()

    file(APPEND "${test_project_src_dir}/main.c" "
          return result;
      }
    ")

    set(_rpath_arg)
    if(APPLE AND ${CMAKE_VERSION} VERSION_GREATER 2.8.11)
      set(_rpath_arg "-DCMAKE_MACOSX_RPATH='${CMAKE_MACOSX_RPATH}'")
    endif()

    try_compile(project_compiles
                "${test_project_bin_dir}"
                "${test_project_src_dir}"
                "${project_name}"
                CMAKE_FLAGS
                  "-DCMAKE_SHARED_LINKER_FLAGS='${CMAKE_SHARED_LINKER_FLAGS}'"
                  "-DCMAKE_ENABLE_EXPORTS=ON"
                  ${_rpath_arg}
                OUTPUT_VARIABLE compile_output)

    set(project_works 1)
    set(run_output)

    if(project_compiles)
      execute_process(COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR}
                              "${test_project_bin_dir}/main"
                      WORKING_DIRECTORY "${test_project_bin_dir}"
                      RESULT_VARIABLE project_works
                      OUTPUT_VARIABLE run_output
                      ERROR_VARIABLE run_output)
    endif()

    set(test_description
        "Weak Link ${target_type} -> ${lib_type} (${link_flag_spec})")

    if(project_works EQUAL 0)
      set(project_works TRUE)
      message(STATUS "Performing Test ${test_description} - Success")
    else()
      set(project_works FALSE)
      message(STATUS "Performing Test ${test_description} - Failed")
      file(APPEND ${CMAKE_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/CMakeError.log
           "Performing Test ${test_description} failed with the "
           "following output:\n"
           "BUILD\n-----\n${compile_output}\nRUN\n---\n${run_output}\n")
    endif()

    set(${can_weak_link_var} ${project_works} PARENT_SCOPE)
    if(project_works)
      set(${project_name} ${link_flag} PARENT_SCOPE)
      break()
    endif()
  endforeach()
endfunction()

function(check_dynamic_lookup)
  # Two signatures are supported:

  if(ARGC EQUAL "1")
    #
    # check_dynamic_lookup(<ResultVar>)
    #
    set(target_type "MODULE")
    set(lib_type "SHARED")
    set(has_dynamic_lookup_var "${ARGV0}")
    set(link_flags_var "unused")

  elseif(ARGC GREATER "2")
    #
    # check_dynamic_lookup(<TargetType>
    #                      <LibType>
    #                      <ResultVar>
    #                      [<LinkFlagsVar>])
    #
    set(target_type "${ARGV0}")
    set(lib_type "${ARGV1}")
    set(has_dynamic_lookup_var "${ARGV2}")
    if(ARGC EQUAL "3")
      set(link_flags_var "unused")
    else()
      set(link_flags_var "${ARGV3}")
    endif()
  else()
    message(FATAL_ERROR "missing arguments")
  endif()

  _check_dynamic_lookup(
    ${target_type}
    ${lib_type}
    ${has_dynamic_lookup_var}
    ${link_flags_var}
    )
  set(${has_dynamic_lookup_var} ${${has_dynamic_lookup_var}} PARENT_SCOPE)
  if(NOT "x${link_flags_var}x" STREQUAL "xunusedx")
    set(${link_flags_var} ${${link_flags_var}} PARENT_SCOPE)
  endif()
endfunction()

function(_check_dynamic_lookup
         target_type
         lib_type
         has_dynamic_lookup_var
         link_flags_var
         )

  # hash the CMAKE_FLAGS passed and check cache to know if we need to rerun
  if("${target_type}" STREQUAL "STATIC")
    string(MD5 cmake_flags_hash "${CMAKE_STATIC_LINKER_FLAGS}")
  else()
    string(MD5 cmake_flags_hash "${CMAKE_SHARED_LINKER_FLAGS}")
  endif()

  set(cache_var "HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}")
  set(cache_hash_var "HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}_hash")
  set(result_var "DYNAMIC_LOOKUP_FLAGS_${target_type}_${lib_type}")

  if(     NOT DEFINED ${cache_hash_var}
       OR NOT "${${cache_hash_var}}" STREQUAL "${cmake_flags_hash}")
    unset(${cache_var} CACHE)
  endif()

  if(NOT DEFINED ${cache_var})
    set(skip_test FALSE)

   if(CMAKE_CROSSCOMPILING AND NOT CMAKE_CROSSCOMPILING_EMULATOR)
      set(skip_test TRUE)
    endif()

    if(skip_test)
      set(has_dynamic_lookup FALSE)
      set(link_flags)
    else()
      _test_weak_link_project(${target_type}
                              ${lib_type}
                              has_dynamic_lookup
                              link_flags)
    endif()

    set(caveat " (when linking ${target_type} against ${lib_type})")

    set(${cache_var} "${has_dynamic_lookup}"
        CACHE BOOL
        "linker supports dynamic lookup for undefined symbols${caveat}")
    mark_as_advanced(${cache_var})

    set(${result_var} "${link_flags}"
        CACHE STRING
        "linker flags for dynamic lookup${caveat}")
    mark_as_advanced(${result_var})

    set(${cache_hash_var} "${cmake_flags_hash}"
        CACHE INTERNAL "hashed flags for ${cache_var} check")
  endif()

  set(${has_dynamic_lookup_var} "${${cache_var}}" PARENT_SCOPE)
  set(${link_flags_var} "${${result_var}}" PARENT_SCOPE)
endfunction()

function(target_link_libraries_with_dynamic_lookup target)
  _get_target_type(target_type ${target})

  set(link_props)
  set(link_items)
  set(link_libs)

  foreach(lib ${ARGN})
    _get_target_type(lib_type ${lib})
    check_dynamic_lookup(${target_type}
                         ${lib_type}
                         has_dynamic_lookup
                         dynamic_lookup_flags)

    if(has_dynamic_lookup)
      if(dynamic_lookup_flags)
        if("${target_type}" STREQUAL "EXE")
          list(APPEND link_items "${dynamic_lookup_flags}")
        else()
          list(APPEND link_props "${dynamic_lookup_flags}")
        endif()
      endif()
    elseif(${lib} MATCHES "(debug|optimized|general)")
      # See gh-255
    else()
      list(APPEND link_libs "${lib}")
    endif()
  endforeach()

  if(link_props)
    list(REMOVE_DUPLICATES link_props)
  endif()

  if(link_items)
    list(REMOVE_DUPLICATES link_items)
  endif()

  if(link_libs)
    list(REMOVE_DUPLICATES link_libs)
  endif()

  if(link_props)
    set_target_properties(${target}
                          PROPERTIES LINK_FLAGS "${link_props}")
  endif()

  set(links "${link_items}" "${link_libs}")
  if(links)
    target_link_libraries(${target} "${links}")
  endif()
endfunction()



set(_command "
import distutils.sysconfig
import itertools
import os
import os.path
import site
import sys

result = None
rel_result = None
candidate_lists = []

try:
    candidate_lists.append((distutils.sysconfig.get_python_lib(),))
except AttributeError: pass

try:
    candidate_lists.append(site.getsitepackages())
except AttributeError: pass

try:
    candidate_lists.append((site.getusersitepackages(),))
except AttributeError: pass

candidates = itertools.chain.from_iterable(candidate_lists)

for candidate in candidates:
    rel_candidate = os.path.relpath(
      candidate, sys.prefix)
    if not rel_candidate.startswith(\"..\"):
        result = candidate
        rel_result = rel_candidate
        break

ext_suffix_var = 'SO'
if sys.version_info[:2] >= (3, 5):
    ext_suffix_var = 'EXT_SUFFIX'

sys.stdout.write(\";\".join((
    os.sep,
    os.pathsep,
    sys.prefix,
    result,
    rel_result,
    distutils.sysconfig.get_config_var(ext_suffix_var)
)))
")

execute_process(COMMAND "${PYTHON_EXECUTABLE}" -c "${_command}"
                OUTPUT_VARIABLE _list
                RESULT_VARIABLE _result)

list(GET _list 0 _item)
set(PYTHON_SEPARATOR "${_item}")
mark_as_advanced(PYTHON_SEPARATOR)

list(GET _list 1 _item)
set(PYTHON_PATH_SEPARATOR "${_item}")
mark_as_advanced(PYTHON_PATH_SEPARATOR)

list(GET _list 2 _item)
set(PYTHON_PREFIX "${_item}")
mark_as_advanced(PYTHON_PREFIX)

list(GET _list 3 _item)
set(PYTHON_SITE_PACKAGES_DIR "${_item}")
mark_as_advanced(PYTHON_SITE_PACKAGES_DIR)

list(GET _list 4 _item)
set(PYTHON_RELATIVE_SITE_PACKAGES_DIR "${_item}")
mark_as_advanced(PYTHON_RELATIVE_SITE_PACKAGES_DIR)

if(NOT DEFINED PYTHON_EXTENSION_MODULE_SUFFIX)
  list(GET _list 5 _item)
  set(PYTHON_EXTENSION_MODULE_SUFFIX "${_item}")
endif()

function(_set_python_extension_symbol_visibility _target)
  if(PYTHON_VERSION_MAJOR VERSION_GREATER 2)
    set(_modinit_prefix "PyInit_")
  else()
    set(_modinit_prefix "init")
  endif()
  #message("_modinit_prefix:${_modinit_prefix}")
  if("${CMAKE_C_COMPILER_ID}" STREQUAL "MSVC")
    set_target_properties(${_target} PROPERTIES LINK_FLAGS 
        "/EXPORT:${_modinit_prefix}${_target}"
    )
  elseif("${CMAKE_C_COMPILER_ID}" STREQUAL "GNU" AND NOT ${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    set(_script_path
      ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${_target}-version-script.map
    )
    file(WRITE ${_script_path} 
               "{global: ${_modinit_prefix}${_target}; local: *; };"
    )
    set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS
        " -Wl,--version-script=\"${_script_path}\""
    )
  endif()
endfunction()

function(python_extension_module _target)
  set(one_ops LINKED_MODULES_VAR FORWARD_DECL_MODULES_VAR MODULE_SUFFIX)
  cmake_parse_arguments(_args "" "${one_ops}" "" ${ARGN})

  set(_lib_type "NA")
  if(TARGET ${_target})
    get_property(_lib_type TARGET ${_target} PROPERTY TYPE)
  endif()

  set(_is_non_lib TRUE)

  set(_is_static_lib FALSE)
  if(_lib_type STREQUAL "STATIC_LIBRARY")
      set(_is_static_lib TRUE)
      set(_is_non_lib FALSE)
  endif()

  set(_is_shared_lib FALSE)
  if(_lib_type STREQUAL "SHARED_LIBRARY")
      set(_is_shared_lib TRUE)
      set(_is_non_lib FALSE)
  endif()

  set(_is_module_lib FALSE)
  if(_lib_type STREQUAL "MODULE_LIBRARY")
      set(_is_module_lib TRUE)
      set(_is_non_lib FALSE)
  endif()

  if(_is_static_lib OR _is_shared_lib OR _is_non_lib)

    if(_is_static_lib OR _is_shared_lib)
      if(_args_LINKED_MODULES_VAR)
        set(${_args_LINKED_MODULES_VAR}
            ${${_args_LINKED_MODULES_VAR}} ${_target} PARENT_SCOPE)
      else()
        set_property(GLOBAL APPEND PROPERTY PY_LINKED_MODULES_LIST ${_target})
      endif()
    endif()

    if(_args_FORWARD_DECL_MODULES_VAR)
      set(${_args_FORWARD_DECL_MODULES_VAR}
          ${${_args_FORWARD_DECL_MODULES_VAR}} ${_target} PARENT_SCOPE)
    else()
      set_property(GLOBAL APPEND PROPERTY
                   PY_FORWARD_DECL_MODULES_LIST ${_target})
    endif()
  endif()

  if(NOT _is_non_lib)
    include_directories("${PYTHON_INCLUDE_DIRS}")
  endif()

  if(_is_module_lib)
    set_target_properties(${_target} PROPERTIES
                          PREFIX "${PYTHON_MODULE_PREFIX}")
  endif()

  if(_is_module_lib OR _is_shared_lib)
    if(_is_module_lib)

      if(NOT _args_MODULE_SUFFIX)
        set(_args_MODULE_SUFFIX "${PYTHON_EXTENSION_MODULE_SUFFIX}")
      endif()

      if(_args_MODULE_SUFFIX STREQUAL "" AND WIN32 AND NOT CYGWIN)
        set(_args_MODULE_SUFFIX ".pyd")
      endif()

      if(NOT _args_MODULE_SUFFIX STREQUAL "")
        set_target_properties(${_target}
          PROPERTIES SUFFIX ${_args_MODULE_SUFFIX})
      endif()
    endif()

    target_link_libraries_with_dynamic_lookup(${_target} ${PYTHON_LIBRARIES})
    
    if(_is_module_lib)
      _set_python_extension_symbol_visibility(${_target})
    endif()
  endif()
endfunction()

function(python_standalone_executable _target)
  include_directories(${PYTHON_INCLUDE_DIRS})
  target_link_libraries(${_target} ${PYTHON_LIBRARIES})
endfunction()

function(python_modules_header _name)
  set(one_ops FORWARD_DECL_MODULES_LIST
              HEADER_OUTPUT_VAR
              INCLUDE_DIR_OUTPUT_VAR)
  cmake_parse_arguments(_args "" "${one_ops}" "" ${ARGN})

  list(GET _args_UNPARSED_ARGUMENTS 0 _arg0)
  # if present, use arg0 as the input file path
  if(_arg0)
    set(_source_file ${_arg0})

  # otherwise, must determine source file from name, or vice versa
  else()
    get_filename_component(_name_ext "${_name}" EXT)

    # if extension provided, _name is the source file
    if(_name_ext)
      set(_source_file ${_name})
      get_filename_component(_name "${_source_file}" NAME_WE)

    # otherwise, assume the source file is ${_name}.h
    else()
      set(_source_file ${_name}.h)
    endif()
  endif()

  if(_args_FORWARD_DECL_MODULES_LIST)
    set(static_mod_list ${_args_FORWARD_DECL_MODULES_LIST})
  else()
    get_property(static_mod_list GLOBAL PROPERTY PY_FORWARD_DECL_MODULES_LIST)
  endif()

  string(REPLACE "." "_" _header_name "${_name}")
  string(TOUPPER ${_header_name} _header_name_upper)
  set(_header_name_upper "_${_header_name_upper}_H")
  set(generated_file ${CMAKE_CURRENT_BINARY_DIR}/${_source_file})

  set(generated_file_tmp "${generated_file}.in")
  file(WRITE ${generated_file_tmp}
       "/* Created by CMake. DO NOT EDIT; changes will be lost. */\n")

  set(_chunk "")
  set(_chunk "${_chunk}#ifndef ${_header_name_upper}\n")
  set(_chunk "${_chunk}#define ${_header_name_upper}\n")
  set(_chunk "${_chunk}\n")
  set(_chunk "${_chunk}#include <Python.h>\n")
  set(_chunk "${_chunk}\n")
  set(_chunk "${_chunk}#ifdef __cplusplus\n")
  set(_chunk "${_chunk}extern \"C\" {\n")
  set(_chunk "${_chunk}#endif /* __cplusplus */\n")
  set(_chunk "${_chunk}\n")
  set(_chunk "${_chunk}#if PY_MAJOR_VERSION < 3\n")
  file(APPEND ${generated_file_tmp} "${_chunk}")

  foreach(_module ${static_mod_list})
    file(APPEND ${generated_file_tmp}
         "PyMODINIT_FUNC init${PYTHON_MODULE_PREFIX}${_module}(void);\n")
  endforeach()

  file(APPEND ${generated_file_tmp} "#else /* PY_MAJOR_VERSION >= 3*/\n")

  foreach(_module ${static_mod_list})
    file(APPEND ${generated_file_tmp}
         "PyMODINIT_FUNC PyInit_${PYTHON_MODULE_PREFIX}${_module}(void);\n")
  endforeach()

  set(_chunk "")
  set(_chunk "${_chunk}#endif /* PY_MAJOR_VERSION >= 3*/\n\n")
  set(_chunk "${_chunk}#ifdef __cplusplus\n")
  set(_chunk "${_chunk}}\n")
  set(_chunk "${_chunk}#endif /* __cplusplus */\n")
  set(_chunk "${_chunk}\n")
  file(APPEND ${generated_file_tmp} "${_chunk}")

  foreach(_module ${static_mod_list})
    set(_import_function "${_header_name}_${_module}")
    set(_prefixed_module "${PYTHON_MODULE_PREFIX}${_module}")

    set(_chunk "")
    set(_chunk "${_chunk}int ${_import_function}(void)\n")
    set(_chunk "${_chunk}{\n")
    set(_chunk "${_chunk}  static char name[] = \"${_prefixed_module}\";\n")
    set(_chunk "${_chunk}  #if PY_MAJOR_VERSION < 3\n")
    set(_chunk "${_chunk}  return PyImport_AppendInittab(")
    set(_chunk "${_chunk}name, init${_prefixed_module});\n")
    set(_chunk "${_chunk}  #else /* PY_MAJOR_VERSION >= 3 */\n")
    set(_chunk "${_chunk}  return PyImport_AppendInittab(")
    set(_chunk "${_chunk}name, PyInit_${_prefixed_module});\n")
    set(_chunk "${_chunk}  #endif /* PY_MAJOR_VERSION >= 3 */\n")
    set(_chunk "${_chunk}}\n\n")
    file(APPEND ${generated_file_tmp} "${_chunk}")
  endforeach()

  file(APPEND ${generated_file_tmp}
       "void ${_header_name}_LoadAllPythonModules(void)\n{\n")
  foreach(_module ${static_mod_list})
    file(APPEND ${generated_file_tmp} "  ${_header_name}_${_module}();\n")
  endforeach()
  file(APPEND ${generated_file_tmp} "}\n\n")

  set(_chunk "")
  set(_chunk "${_chunk}#ifndef EXCLUDE_LOAD_ALL_FUNCTION\n")
  set(_chunk "${_chunk}void CMakeLoadAllPythonModules(void)\n")
  set(_chunk "${_chunk}{\n")
  set(_chunk "${_chunk}  ${_header_name}_LoadAllPythonModules();\n")
  set(_chunk "${_chunk}}\n")
  set(_chunk "${_chunk}#endif /* !EXCLUDE_LOAD_ALL_FUNCTION */\n\n")

  set(_chunk "${_chunk}#ifndef EXCLUDE_PY_INIT_WRAPPER\n")
  set(_chunk "${_chunk}static void Py_Initialize_Wrapper()\n")
  set(_chunk "${_chunk}{\n")
  set(_chunk "${_chunk}  ${_header_name}_LoadAllPythonModules();\n")
  set(_chunk "${_chunk}  Py_Initialize();\n")
  set(_chunk "${_chunk}}\n")
  set(_chunk "${_chunk}#define Py_Initialize Py_Initialize_Wrapper\n")
  set(_chunk "${_chunk}#endif /* !EXCLUDE_PY_INIT_WRAPPER */\n\n")

  set(_chunk "${_chunk}#endif /* !${_header_name_upper} */\n")
  file(APPEND ${generated_file_tmp} "${_chunk}")

  # with configure_file() cmake complains that you may not use a file created
  # using file(WRITE) as input file for configure_file()
  execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different
                  "${generated_file_tmp}" "${generated_file}"
                  OUTPUT_QUIET ERROR_QUIET)

  set(_header_output_var ${_name})
  if(_args_HEADER_OUTPUT_VAR)
    set(_header_output_var ${_args_HEADER_OUTPUT_VAR})
  endif()
  set(${_header_output_var} ${generated_file} PARENT_SCOPE)

  set(_include_dir_var ${_name}_INCLUDE_DIRS)
  if(_args_INCLUDE_DIR_OUTPUT_VAR)
    set(_include_dir_var ${_args_INCLUDE_DIR_OUTPUT_VAR})
  endif()
  set(${_include_dirs_var} ${CMAKE_CURRENT_BINARY_DIR} PARENT_SCOPE)
endfunction()

